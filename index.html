<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="something, i guess">
    <link href="table.css" rel="stylesheet" />
    <title>bitwizardry</title>
</head>
<body style="background-color: black">
    <a class="link" href="https://sky4ce09.github.io/bitwizard/spriting/sprites.html">Check out the new spriting environment here</a><br/>
	<textarea style="background-color: black; color: white" cols=80 rows=60 id="inputfield" placeholder="Input" oninput="document.getElementById(`outputfield`).value = tp(document.getElementById(`inputfield`).value)"></textarea>
	<textarea style="background-color: black; color: white" cols=80 rows=60 readonly id="outputfield" placeholder="Output"></textarea>
	<section>
		<article>
		<h3 style="color: white; font-family: arial, sans-serif">bitwizard simplified bit manipulation & other tools for mindustry logic // mixed mlog and custom ops</h3>
        <table><tbody style="color: white">
            <tr>
                <th>main instruction / instruction set</th>
                <th>sub instruction</th>
                <th>parameters</th>
                <th>purpose & details</th>
                <th>example</th>
            </tr>
            <tr>
                <td>timer</td>
                <td>new</td>
                <td>name, duration in ms</td>
                <td>create and start a timer</td>
                <td>timer new BakePretzelTimer 1200000</td>
            </tr>
            <tr>
                <td></td>
                <td>loop</td>
                <td>name</td>
                <td>determine the line of code a timer should jump to if it's not expired (the line below)</td>
                <td>timer loop BakePretzelTimer<br />op add becomeImpatient becomeImpatient 1</td>
            </tr>
            <tr>
                <td></td>
                <td>extend</td>
                <td>name, duration in ms</td>
                <td>extend a timer</td>
                <td>timer extend BakePretzelTimer 60000</td>
            </tr>
            <tr>
                <td></td>
                <td>close</td>
                <td></td>
                <td>close the most recently created timer</td>
                <td>timer new Wait2secs 2000<br />timer loop Wait2secs<br />timer close</td>
            </tr>
            <tr>
                <td>consistent (alias: con)</td>
                <td></td>
                <td></td>
                <td>disables line count optimization for instructions below this tag</td>
                <td>consistent <br />spl of value SomeRandomSplit 0 #becomes 2 lines instead of 1 for given index 0 due to line count consistency</td>
            </tr>
            <tr>
                <td>inconsistent (alias: incon)</td>
                <td></td>
                <td></td>
                <td>enables line count optimization for instructions below this tag, is the default setting</td>
                <td>incon <br />spl of value SomeRandomSplit 0 #output is back to default 1 line</td>
                    </tr>
            <tr>
                <td>spl*</td>
                <td>new</td>
                <td>target variable name, reference name, bitcounts...</td>
                <td>create a bit splitter for a variable</td>
                <td>spl new bytes Bytes 8 8 8 8 8 8 #splits 'bytes' into 6 actual bytes</td>
            </tr>
            <tr>
                <td></td>
                <td>obtainf*</td>
                <td>output variable, splitter reference, constant bitcount index</td>
                <td>get the range of bits of a splitter's target variable at a constant index</td>
                <td>spl obtainf a Bytes 1 #gets the 2nd range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td></td>
                <td>obtaind</td>
                <td>output variable, splitter reference, bitcount index</td>
                <td>get the range of bits of a splitter's target variable at an index that may be determined in runtime<br />this generates a lot more code than obtainf so don't use it when you don't need to define the bit range index in runtime</td>
                <td>spl obtaind a Bytes x #gets the x-th range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td></td>
                <td>clearf</td>
                <td>splitter reference, constant bitcount index</td>
                <td>clear the range of bits of a splitter's target variable at a constant index</td>
                <td>spl clearf Bytes 3 #clears the 4th range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td></td>
                <td>cleard</td>
                <td>splitter reference, bitcount index</td>
                <td>clear the range of bits of a splitter's target variable at an index that may be determined in runtime<br />this generates a lot more code than clearf so don't use it when you don't need to define the bit range index in runtime</td>
                <td>spl cleard Bytes x #clears the x-th range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td></td>
                <td>writef*</td>
                <td>input, splitter reference, constant bitcount index</td>
                <td>write to the range of bits of a splitter's target variable at a constant index</td>
                <td>spl writef 0b10100101 Bytes 3 #writes a number to the 4th range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td></td>
                <td>writed*</td>
                <td>input, splitter reference, bitcount index</td>
                <td>write to the range of bits of a splitter's target variable at an index that may be determined in runtime<br />this generates a lot more code than writef so don't use it when you don't need to define the bit range index in runtime</td>
                <td>spl writed 0xFF Bytes x #writes a number to the x-th range of bits in 'Bytes'</td>
            </tr>
            <tr>
                <td>fun</td>
                <td>new</td>
                <td>name</td>
                <td>declare a new function</td>
                <td>fun new ConstructingAdditionalPylons</td>
            </tr>
            <tr>
                <td></td>
                <td>close</td>
                <td></td>
                <td>close the most recently declared function</td>
                <td>fun close</td>
            </tr>
            <tr>
                <td></td>
                <td>have / call</td>
                <td>function name</td>
                <td>have fun™ / call a function</td>
                <td>fun have ConstructingAdditionalPylons</td>
            </tr>
            <tr>
                <td>uflag</td>
                <td>(empty)</td>
                <td>flag value</td>
                <td>set @unit's flag to the provided flag value</td>
                <td>uflag 64 #so much shorter</td>
            </tr>
            <tr>
                <td></td>
                <td>get</td>
                <td>unit type, flag value search, (escape conditions...)</td>
                <td>will try to bind @unit to an UNCONTROLLED unit of the provided unit type, with the specified flag; @unit escape conditions may be used to break out of the loop</td>
                <td>uflag get @oct 0 === null<br />jump noOctsPresent equal @unit null<br /># makes use of escape conditions to tell whether a unit of a unit type is present</td>
            </tr>
            <tr>
                <td></td>
                <td>get any</td>
                <td>unit type, flag value search, (escape conditions...)</td>
                <td>will try to bind @unit to ANY unit of the provided unit type, with the specified flag; once again, @unit escape conditions may be used to break out of the loop</td>
                <td>uflag get any @quad 0<br />uflag 69</td>
            </tr>
            <tr>
                <td></td>
                <td>await</td>
                <td>condition</td>
                <td>causes the processor to loop until @unit's flag meets the specified condition</td>
                <td>set signal 6942069420<br />uflag signal<br />uflag await not signal<br /># this is how to do the network</td>
            </tr>
            <tr>
                <td></td>
                <td>test</td>
                <td>condition, output variable</td>
                <td>test's @unit's flag for the specified condition</td>
                <td>uflag test == 0 lol</td>
            </tr>
            <tr>
                <td></td>
                <td>verify</td>
                <td>jump target OR function name</td>
                <td>will (call / jump to) the specified target if @unit is<br />A. dead <br />B. controlled by another processor</td>
                <td>myLabel:<br />uflag get any @flare 0<br />wait 5s<br />uflag verify myLabel</td>
            </tr>
            <tr>
                <td>log2</td>
                <td></td>
                <td>output, input</td>
                <td>get the base 2 logarithm of a number; automatically imports LN2 if necessary</td>
                <td>log2 x 16</td>
            </tr>
            <tr>
                <td>define</td>
                <td>LN2</td>
                <td></td>
                <td>define a variable 'LN2' as the natural logarithm of 2 at the start of your code</td>
                <td>define LN2<br />print LN2<br />printf message1 #gimme ln2</td>
            </tr>
            <tr>
                <td></td>
                <td>LN16</td>
                <td></td>
                <td>define a variable 'LN16' as the natural logarithm of 16 at the start of your code</td>
                <td>define LN16</td>
            </tr>
            <tr>
                <td></td>
                <td>PI</td>
                <td></td>
                <td>define a variable 'PI' as a 16-digit approximate of pi at the start of your code</td>
                <td>define PI</td>
            </tr>
            <tr>
                <td>parray</td>
                <td></td>
                <td>constant pointer count, value</td>
                <td>create a pointer array (note that these pile to a lot of instructions)</td>
                <td>parray 8 a</td>
            </tr>
            <tr>
                <td>/</td>
                <td></td>
                <td></td>
                <td>close one case of a pointer array</td>
                <td>parr 2 fruit<br />set x "apple"<br />/<br />set x "orange"<br />/</td>
            </tr>
            <tr>
                <td>for</td>
                <td></td>
                <td>variable, (optional = assignment), conditional operator, condition right side, (!recommended! increment value)</td>
                <td>create a for loop to be used in conjunction with 'next'</td>
                <td>for x = y != 10 z<br>next</td>
            </tr>
            <tr>
                <td>next</td>
                <td></td>
                <td></td>
                <td>close the most recently created for loop</td>
                <td>for x not 10 1<br>next</td>
            </tr>
        </tbody></table>
		</article>
        <article>
        <p style="color: white; font-family: Calibri">*: in part or wholly affected by line inconsistency and the 'consistent' tag</p>
        </article>
		<article>
		<p><a class="link" href="https://sky4ce09.github.io/home/">Home</a>
		</article>
	</section>
	<script src="transpile.js"></script>
</body>
</html>